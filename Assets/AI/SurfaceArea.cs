// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using Completed;
using System;

public class SurfaceArea : AIBase
{ //this agent attemps to find the closest enemy and move closer to it
	public override void onTurn()
	{
		base.onTurn();
		foreach(Enemy e in self) { //for each enemy, find its closest ally
			Vector3 cur = e.currentPos;
			Enemy closestEnemy = null;
			int closestDistance = 9999999;
			MovingObject closestTarget = null;
			int closestTargDistance = 9999999;
			foreach(Enemy j in self) { //find closest enemy
				if (j != e) {
					if (closestEnemy != null) {
						closestEnemy = j;
						closestDistance = (int)Mathf.Sqrt(Mathf.Pow((j.transform.position.x - cur.x), 2) + Mathf.Pow((j.transform.position.y - cur.y), 2));
					}
					else {
						float distance = Mathf.Sqrt(Mathf.Pow((j.transform.position.x - cur.x), 2) + Mathf.Pow((j.transform.position.y - cur.y), 2));
						if (distance < closestDistance)
						{
							closestDistance = (int)distance;
							closestEnemy = j;
						}
					}
				}
			}
			foreach(MovingObject obj in other) { //find closest object
				if (closestTarget != null) {
					closestTarget = obj;
					closestTargDistance = (int)Mathf.Sqrt(Mathf.Pow((obj.transform.position.x - cur.x), 2) + Mathf.Pow((obj.transform.position.y - cur.y), 2));
				}
				else {
					float distance = Mathf.Sqrt(Mathf.Pow((obj.transform.position.x - cur.x), 2) + Mathf.Pow((obj.transform.position.y - cur.y), 2));
					if (distance < closestTargDistance)
					{
						closestTargDistance = (int)distance;
						closestTarget = obj;
					}
				}
			}
			int xDir = 0;
			int yDir = 0;
			if (closestDistance <= closestTargDistance) { //if enemy is closer, then move towards it
				bool xComparison = Mathf.Abs(closestEnemy.transform.position.x - cur.x) < float.Epsilon;
				bool yComparison = Mathf.Abs(closestEnemy.transform.position.y - cur.y) < float.Epsilon;
				if (xComparison)
				{
					yDir = closestEnemy.transform.position.y > cur.y ? 1 : -1;
				}
				else
				{
					xDir = closestEnemy.transform.position.x > cur.x ? 1 : -1;
				}
				actions.Add(new AIAction(e, AIAction.Actions.Move, cur + new Vector3(xDir, yDir, 0)));
			}
			else { //if target is closer, then move towards it and attack it if needed
				bool xComparison = Mathf.Abs(closestTarget.transform.position.x - cur.x) < float.Epsilon;
				bool yComparison = Mathf.Abs(closestTarget.transform.position.y - cur.y) < float.Epsilon;
				if (xComparison)
				{
					yDir = closestTarget.transform.position.y > cur.y ? 1 : -1;
				}
				else
				{
					xDir = closestTarget.transform.position.x > cur.x ? 1 : -1;
				}
				actions.Add(new AIAction(e, AIAction.Actions.Move, cur + new Vector3(xDir, yDir, 0)));
			}

		}
	}
}
